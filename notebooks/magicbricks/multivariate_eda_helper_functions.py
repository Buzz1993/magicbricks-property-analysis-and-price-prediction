{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "3d345431-f862-4bb9-a3be-7e22eaaac716",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import ast\n",
    "from scipy.stats import iqr,yeojohnson, skew, kurtosis\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "import missingno as msno\n",
    "\n",
    "import regex as re\n",
    "import eda_helper_functions\n",
    "import matplotlib.gridspec as gridspec\n",
    "import scipy.stats as stats\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "30e92a3d-7005-4f9a-b5d4-3bcd124e3c60",
   "metadata": {},
   "source": [
    "# User-Defined Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "26b7d2b8-8d2a-4285-adc4-74d7da4b8089",
   "metadata": {},
   "source": [
    "make price_category in order while plotting in graph "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "b1c9c6b2-8379-4fc3-85d5-6eb71e4c6476",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the desired order\n",
    "price_order = [\n",
    "    \"0.00 - 0.99\",  \n",
    "    \"1.00 - 1.99\",  \n",
    "    \"2.00 - 2.99\",  \n",
    "    \"3.00 - 3.99\",  \n",
    "    \"4.00 - 4.99\",  \n",
    "    \"5.00 - 5.99\",  \n",
    "    \"6.00 - 6.99\",  \n",
    "    \"7.00 - 7.99\",  \n",
    "    \"8.00 - 8.99\",  \n",
    "    \"9.00 - 9.99\",  \n",
    "    \"10.00 - 14.99\",  \n",
    "    \"15.00 - 20.00\",  \n",
    "    \"20.00 and above\"\n",
    "]\n",
    "\n",
    "# Convert the column to a categorical type with the specified order.\n",
    "df['price_category'] = pd.Categorical(df['price_category'], categories=price_order, ordered=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e9adcde5-69f3-4e41-8c8a-3884a38f106c",
   "metadata": {},
   "source": [
    "use to plot Boxen Plot, Box Plot, Bar Plot (Mean), Bar Plot (Median), Count Plot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "8534d376-b212-4cd6-aa74-2ba78543bb7b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def num_charts_plot(df, feature):\n",
    "    \"\"\"\n",
    "    Alternative plots for a numerical feature with high cardinality:\n",
    "      - Boxen Plot\n",
    "      - Box Plot\n",
    "      - Violin Plot\n",
    "      - Line Plot of aggregated price by feature (assumed ordinal)\n",
    "      - Heatmap of median price by feature\n",
    "      - Jittered Strip Plot of Price by feature\n",
    "      - Count Plot      \n",
    "    \"\"\"\n",
    "    \n",
    "    # Increase figure height to accommodate an additional plot (16 rows)\n",
    "    fig = plt.figure(constrained_layout=True, figsize=(20, 35))\n",
    "    grid = gridspec.GridSpec(ncols=2, nrows=16, figure=fig)\n",
    "    \n",
    "    # 1. Boxen Plot\n",
    "    ax1 = fig.add_subplot(grid[0:2, :])\n",
    "    ax1.set_title('Boxen Plot')\n",
    "    sns.boxenplot(x=df[feature], y=df['price'], ax=ax1)\n",
    "    ax1.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    # 2. Box Plot\n",
    "    ax2 = fig.add_subplot(grid[2:4, :])\n",
    "    ax2.set_title('Box Plot')\n",
    "    sns.boxplot(x=df[feature], y=df['price'], ax=ax2)\n",
    "    ax2.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    # 3. Violin Plot\n",
    "    ax3 = fig.add_subplot(grid[4:6, :])\n",
    "    ax3.set_title('Violin Plot')\n",
    "    sns.violinplot(x=df[feature], y=df['price'], data=df, ax=ax3)\n",
    "    ax3.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    # 4. Line Plot (Mean and Median)\n",
    "    ax4 = fig.add_subplot(grid[6:8, :])\n",
    "    ax4.set_title('Line Plot of Aggregated Price by ' + feature)\n",
    "    \n",
    "    # Compute aggregated values\n",
    "    agg_data = df.groupby(feature)['price'].agg(['mean', 'median']).reset_index()\n",
    "    agg_data = agg_data.sort_values(feature)\n",
    "    \n",
    "    # Plot mean and median\n",
    "    ax4.plot(agg_data[feature], agg_data['mean'], marker='o', label='Mean Price', color='#1f77b4')\n",
    "    ax4.plot(agg_data[feature], agg_data['median'], marker='o', label='Median Price', color='#ff7f0e')\n",
    "    \n",
    "    # Offsets for text placement\n",
    "    y_offset_mean = 0.5\n",
    "    y_offset_median = -0.5\n",
    "    \n",
    "    # Annotate mean (vertical text)\n",
    "    for x_val, y_val in zip(agg_data[feature], agg_data['mean']):\n",
    "        ax4.text(x_val, y_val + y_offset_mean, f\"{y_val:.2f}\",\n",
    "                 ha='center', va='bottom', fontsize=10, color='#1f77b4', rotation=90)\n",
    "    \n",
    "    # Annotate median (vertical text)\n",
    "    for x_val, y_val in zip(agg_data[feature], agg_data['median']):\n",
    "        ax4.text(x_val, y_val + y_offset_median, f\"{y_val:.2f}\",\n",
    "                 ha='center', va='top', fontsize=10, color='#ff7f0e', rotation=90)\n",
    "    \n",
    "    ax4.legend()\n",
    "    ax4.tick_params(axis='x', rotation=90)\n",
    "    ax4.set_xlabel(feature)\n",
    "    ax4.set_ylabel('Mean and Median Price')\n",
    "    \n",
    "    # 5. Heatmap of Median Price by feature\n",
    "    ax5 = fig.add_subplot(grid[8:10, :])\n",
    "    ax5.set_title('Heatmap of Median Price by ' + feature)\n",
    "    \n",
    "    # Reuse the agg_data focusing on the median\n",
    "    heat_data = agg_data.set_index(feature)[['median']].T\n",
    "    \n",
    "    sns.heatmap(\n",
    "        heat_data,\n",
    "        annot=True,           # show numeric values\n",
    "        fmt=\".2f\",            # decimal format for numbers\n",
    "        cmap=\"viridis\", \n",
    "        ax=ax5,\n",
    "        cbar=True,            # show colorbar\n",
    "        linewidths=0.5,       # lines between cells\n",
    "        linecolor='white',\n",
    "        annot_kws={\"size\": 12, \"rotation\": 90}  # vertical annotation text\n",
    "    )\n",
    "    \n",
    "    # Optionally rotate tick labels for x or y axes\n",
    "    ax5.set_xticklabels(ax5.get_xticklabels(), rotation=45, ha='right')\n",
    "    ax5.set_yticklabels(ax5.get_yticklabels(), rotation=0)\n",
    "    \n",
    "    # 6. Jittered Strip Plot\n",
    "    ax6 = fig.add_subplot(grid[10:12, :])\n",
    "    ax6.set_title('Jittered Strip Plot of Price by ' + feature)\n",
    "    \n",
    "    # Compute the median price by feature and sort it\n",
    "    table = df.groupby(feature, as_index=False)['price'].median().sort_values(feature)\n",
    "    \n",
    "    # Create the strip plot with sorted order\n",
    "    a1 = sns.stripplot(data=df, x=feature, y='price', order=table[feature].tolist(), \n",
    "                       jitter=True, alpha=0.6, size=5, ax=ax6)\n",
    "    a1.set_xticklabels(a1.get_xticklabels(), rotation=90)\n",
    "    \n",
    "    # 7. Count Plot\n",
    "    ax7 = fig.add_subplot(grid[12:14, :])\n",
    "    ax7.set_title('Count Plot')\n",
    "    sns.countplot(x=df[feature], ax=ax7)\n",
    "    ax7.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dadac624-a784-44fd-b59d-adfb837fae7f",
   "metadata": {},
   "source": [
    "Confidence Interval comparison"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "146f265c-6f6a-4a77-b002-aad086bab58a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def ci_mean(data, confidence=0.95):\n",
    "    \"\"\"Compute the confidence interval for the mean.\"\"\"\n",
    "    n = len(data)\n",
    "    mean = np.mean(data)\n",
    "    sem = st.sem(data)\n",
    "    h = sem * st.t.ppf((1 + confidence) / 2., n-1)\n",
    "    return mean, mean - h, mean + h\n",
    "\n",
    "def ci_median(data, confidence=0.95, n_bootstrap=1000):\n",
    "    \"\"\"Compute the confidence interval for the median using bootstrapping.\"\"\"\n",
    "    boot_medians = [np.median(np.random.choice(data, size=len(data), replace=True)) \n",
    "                    for _ in range(n_bootstrap)]\n",
    "    med = np.median(data)\n",
    "    lower = np.percentile(boot_medians, (1-confidence)/2 * 100)\n",
    "    upper = np.percentile(boot_medians, (1+confidence)/2 * 100)\n",
    "    return med, lower, upper\n",
    "\n",
    "def bar_plot_mean_median_ci(df, feature, price_col='price', confidence=0.95):\n",
    "    \"\"\"\n",
    "    Create a bar plot with error bars to compare the mean and median price \n",
    "    (with their confidence intervals) for each level of the feature and annotate the CI.\n",
    "    \"\"\"\n",
    "    # Group data by the feature\n",
    "    groups = df.groupby(feature)[price_col]\n",
    "    results = []\n",
    "    \n",
    "    for name, group in groups:\n",
    "        m, m_low, m_high = ci_mean(group, confidence)\n",
    "        med, med_low, med_high = ci_median(group, confidence)\n",
    "        results.append((name, m, m_low, m_high, med, med_low, med_high))\n",
    "        \n",
    "    # Build DataFrame and sort if needed\n",
    "    res_df = pd.DataFrame(results, columns=[feature, 'mean', 'mean_low', 'mean_high', \n",
    "                                              'median', 'median_low', 'median_high'])\n",
    "    res_df.sort_values(feature, inplace=True)\n",
    "    \n",
    "    # Calculate error bars\n",
    "    res_df['mean_err_low'] = res_df['mean'] - res_df['mean_low']\n",
    "    res_df['mean_err_high'] = res_df['mean_high'] - res_df['mean']\n",
    "    # For median, we compute asymmetric error bars\n",
    "    res_df['median_err_low'] = res_df['median'] - res_df['median_low']\n",
    "    res_df['median_err_high'] = res_df['median_high'] - res_df['median']\n",
    "    \n",
    "    # Plotting\n",
    "    fig, ax = plt.subplots(figsize=(12, 6))\n",
    "    width = 0.35  # width of the bars\n",
    "    indices = np.arange(len(res_df))\n",
    "    \n",
    "    # Bar for mean\n",
    "    bars_mean = ax.bar(indices - width/2, res_df['mean'], width, \n",
    "                       yerr=[res_df['mean_err_low'], res_df['mean_err_high']], \n",
    "                       capsize=5, label='Mean Price', color='#1f77b4')\n",
    "    \n",
    "    # Bar for median\n",
    "    bars_median = ax.bar(indices + width/2, res_df['median'], width, \n",
    "                         yerr=[res_df['median_err_low'], res_df['median_err_high']], \n",
    "                         capsize=5, label='Median Price', color='#ff7f0e')\n",
    "    \n",
    "    # Annotate the CI on each bar\n",
    "    for i, row in res_df.iterrows():\n",
    "        # Mean annotation\n",
    "        ax.text(i - width/2, row['mean_high'] + 0.5, \n",
    "                f\"CI: [{row['mean_low']:.1f}, {row['mean_high']:.1f}]\", \n",
    "                ha='center', va='bottom', fontsize=9, color='#1f77b4')\n",
    "        # Median annotation\n",
    "        ax.text(i + width/2, row['median_high'] + 0.5, \n",
    "                f\"CI: [{row['median_low']:.1f}, {row['median_high']:.1f}]\", \n",
    "                ha='center', va='bottom', fontsize=9, color='#ff7f0e')\n",
    "    \n",
    "    ax.set_xlabel(feature)\n",
    "    ax.set_ylabel('Price')\n",
    "    ax.set_title('Mean and Median Price with 95% Confidence Intervals by ' + feature)\n",
    "    ax.set_xticks(indices)\n",
    "    ax.set_xticklabels(res_df[feature], rotation=90)\n",
    "    ax.legend()\n",
    "    \n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "96cf52eb-6a21-41d8-82ef-d6b0d5a12f8f",
   "metadata": {},
   "source": [
    "use to plot Distribution Plot and Scatter Plot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "c556fb27-aa08-44e4-a63c-8ac4782f8e15",
   "metadata": {},
   "outputs": [],
   "source": [
    "def num_two_chart_plot(df, feature):\n",
    "    \"\"\"\n",
    "    The plots include:\n",
    "    - Distribution Plot\n",
    "    - Scatter Plot\n",
    "    \"\"\"\n",
    "    fig, axes = plt.subplots(1, 2, figsize=(12, 6))\n",
    "\n",
    "    # Distribution Plot\n",
    "    sns.histplot(df[feature], kde=True, ax=axes[0])\n",
    "    axes[0].set_title('Distribution Plot', fontsize=12)\n",
    "    axes[0].set_xlabel(feature, fontsize=12)\n",
    "    axes[0].set_ylabel('Count', fontsize=12)\n",
    "    axes[0].tick_params(axis='both', labelsize=10)\n",
    "    axes[0].tick_params(axis='x', rotation=90)  # Apply rotation to x-axis\n",
    "\n",
    "    # Scatter Plot\n",
    "    sns.scatterplot(x=df[feature], y=df['price'], ax=axes[1])\n",
    "    axes[1].set_title('Scatter Plot', fontsize=12)\n",
    "    axes[1].set_xlabel(feature, fontsize=12)\n",
    "    axes[1].set_ylabel('Price', fontsize=12)\n",
    "    axes[1].tick_params(axis='both', labelsize=10)\n",
    "    axes[1].tick_params(axis='x', rotation=90)  # Apply rotation to x-axis\n",
    "\n",
    "    # Tight layout to reduce overlapping\n",
    "    plt.tight_layout()\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9f8f5d08-cdde-4ed7-8ea6-067de78758a0",
   "metadata": {},
   "source": [
    "use to plot count plot, bar plot, KDE plot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "d84276dd-6ead-4a8c-9e42-f769be385a50",
   "metadata": {},
   "outputs": [],
   "source": [
    "def region_plots(df, feature):\n",
    "    \"\"\"\n",
    "    Plots various relationships between the given feature and other attributes, ensuring consistent colors for 'addressregion'.\n",
    "    \"\"\"\n",
    "\n",
    "    # Define a fixed color palette for 'addressregion'\n",
    "    unique_regions = df['addressregion'].dropna().unique()\n",
    "    palette = sns.color_palette(\"tab10\", len(unique_regions))  # Using 'tab10' for distinct colors\n",
    "    region_palette = dict(zip(unique_regions, palette))  # Mapping colors to each region\n",
    "\n",
    "    # Create a figure with a grid of 4 rows x 2 columns\n",
    "    fig = plt.figure(constrained_layout=True, figsize=(30, 30))\n",
    "    grid = gridspec.GridSpec(ncols=3, nrows=5, figure=fig)\n",
    "\n",
    "    # 1. Count plot\n",
    "    ax1 = fig.add_subplot(grid[2, 0])\n",
    "    ax1.set_title(f\"1.Count Plot of '{feature}' by 'addressregion'\")\n",
    "    sns.countplot(x=feature, hue='addressregion', data=df, ax=ax1, palette=region_palette)\n",
    "\n",
    "    # 2. Bar plot: price_category vs feature\n",
    "    ax2 = fig.add_subplot(grid[2, 1])\n",
    "    ax2.set_title(f\"2. Barplot of '{feature}' mean and price categories\")\n",
    "    sns.barplot(x='price_category', y=feature, data=df, ax=ax2, estimator=np.mean, errorbar=None)\n",
    "    ax2.tick_params(axis='x', rotation=90)\n",
    "\n",
    "    # 3. Bar plot: price vs feature by addressregion\n",
    "    ax3 = fig.add_subplot(grid[0, 0])\n",
    "    ax3.set_title(f\"3. Bar Plot of 'price' vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='price', hue='addressregion', data=df, ax=ax3, palette=region_palette)\n",
    "\n",
    "    # 4. Bar plot: area vs feature by addressregion\n",
    "    ax4 = fig.add_subplot(grid[0, 1])\n",
    "    ax4.set_title(f\"4. Bar Plot of 'area' vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='area', hue='addressregion', data=df, ax=ax4, palette=region_palette)\n",
    "\n",
    "    # 5. Bar plot: costpersqft vs feature by addressregion\n",
    "    ax5 = fig.add_subplot(grid[0, 2])\n",
    "    ax5.set_title(f\"5. Bar Plot of 'costpersqft' vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='costpersqft', hue='addressregion', data=df, ax=ax5, palette=region_palette)\n",
    "\n",
    "    # 6. Bar plot: feature vs addressregion\n",
    "    ax6 = fig.add_subplot(grid[2, 2])\n",
    "    ax6.set_title(f\"6. Bar Plot of '{feature}' mean vs 'addressregion'\")\n",
    "    sns.barplot(x='addressregion', y=feature, data=df, ax=ax6, estimator=np.mean, errorbar=None, palette=region_palette)\n",
    "\n",
    "    # 7. KDE plot: Price distribution by feature\n",
    "    ax7 = fig.add_subplot(grid[3, 0])\n",
    "    ax7.set_title(f\"7. Price Distribution by '{feature}' (KDE Plot)\")\n",
    "    sns.kdeplot(data=df, x=\"price\", hue=feature, fill=True, common_norm=False, palette=\"tab10\", linewidth=1.5, ax=ax7, warn_singular=False)\n",
    "    ax7.set_xlabel(\"Price\")\n",
    "    ax7.set_ylabel(\"Density\")\n",
    "\n",
    "    # 8. Price vs Bath (line plot)\n",
    "    ax8 = fig.add_subplot(grid[1, 0])\n",
    "    ax8.set_title(f\"8. Price vs {feature}\")\n",
    "    sns.lineplot(data=df, x=feature, y=\"price\", hue=\"addressregion\", ax=ax8, palette=region_palette)\n",
    "\n",
    "    # 9. Area vs Bath (line plot)\n",
    "    ax9 = fig.add_subplot(grid[1, 1])\n",
    "    ax9.set_title(f\"9. Area vs {feature}\")\n",
    "    sns.lineplot(data=df, x=feature, y=\"area\", hue=\"addressregion\", ax=ax9, palette=region_palette)\n",
    "\n",
    "    # 10. Cost per Sqft vs Bath (line plot)\n",
    "    ax10 = fig.add_subplot(grid[1, 2])\n",
    "    ax10.set_title(f\"10. Cost per Sqft vs {feature}\")\n",
    "    sns.lineplot(data=df, x=feature, y=\"costpersqft\", hue=\"addressregion\", ax=ax10, palette=region_palette)\n",
    "\n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ea20cfbf-674a-4103-a555-48e83ea66002",
   "metadata": {},
   "source": [
    "median plot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "5d0b9fe7-e37d-4da4-828f-0e6871da09c5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def median_plot(df, feature):\n",
    "    # Drop rows with missing values for relevant columns\n",
    "    df = df.dropna(subset=[feature, 'costpersqft', 'area', 'price'])\n",
    "    \n",
    "    # Compute median values for each category in the feature\n",
    "    median_cost = df.groupby(feature)['costpersqft'].median()\n",
    "    median_area = df.groupby(feature)['area'].median()\n",
    "    median_price = df.groupby(feature)['price'].median()\n",
    "    \n",
    "    # Apply log transformation\n",
    "    log_median_cost = np.log1p(median_cost)\n",
    "    log_median_area = np.log1p(median_area)\n",
    "    log_median_price = np.log1p(median_price)\n",
    "    \n",
    "    # Combine data for visualization\n",
    "    median_df = (\n",
    "        pd.DataFrame({\n",
    "            feature: log_median_cost.index, \n",
    "            'Log Median Cost per Sqft': log_median_cost.values, \n",
    "            'Log Median Area': log_median_area.values, \n",
    "            'Log Median Price': log_median_price.values\n",
    "        })\n",
    "        .melt(id_vars=[feature], var_name='Metric', value_name='Log Value')\n",
    "    )\n",
    "    \n",
    "    # Plot the graph\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    ax = sns.lineplot(data=median_df, x=feature, y='Log Value', hue='Metric', marker='o')\n",
    "    \n",
    "    # Annotate each point\n",
    "    for line in ax.lines:\n",
    "        for x, y in zip(line.get_xdata(), line.get_ydata()):\n",
    "            ax.text(x, y, f'{y:.2f}', ha='center', va='bottom', fontsize=9)\n",
    "    \n",
    "    # Set labels and title\n",
    "    plt.xlabel(feature, fontsize=12)\n",
    "    plt.ylabel(\"Log Median Values\", fontsize=12)\n",
    "    plt.title(\"Log Median Cost per Sqft, Area, and Price by \" + feature + \" (Line Plot)\", fontsize=14)\n",
    "    plt.xticks(rotation=45)\n",
    "    \n",
    "    # Move legend outside the plot\n",
    "    plt.legend(title=\"Metric\", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=12, frameon=True)\n",
    "    \n",
    "    # Adjust layout\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Create a sorted DataFrame (from expensive to cheapest)\n",
    "    sorted_df = pd.DataFrame({\n",
    "        feature: log_median_cost.index, \n",
    "        'log_median_costpersqft_values': log_median_cost.values  # Renamed column\n",
    "    }).sort_values(by='log_median_costpersqft_values', ascending=False)\n",
    "    \n",
    "    # Print the sorted table\n",
    "    print(sorted_df.to_string(index=False))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "80ae3c3a-5569-4bd5-88f2-f1524063154c",
   "metadata": {},
   "source": [
    "median plot for high cardinality "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "f667c816-9312-438b-a8ae-c83b794c302d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def median_plot_high_card(df, feature):\n",
    "    # Drop rows with missing values for the relevant columns to avoid issues during groupby or log transform\n",
    "    df = df.dropna(subset=[feature, 'costpersqft', 'area', 'price'])\n",
    "    \n",
    "    # Compute median values for each category in the feature\n",
    "    median_cost = df.groupby(feature)['costpersqft'].median()\n",
    "    median_area = df.groupby(feature)['area'].median()\n",
    "    median_price = df.groupby(feature)['price'].median()\n",
    "    \n",
    "    # Apply log transformation using np.log1p to handle zeros gracefully\n",
    "    median_cost = np.log1p(median_cost)\n",
    "    median_area = np.log1p(median_area)\n",
    "    median_price = np.log1p(median_price)\n",
    "    \n",
    "    # Combine data into a single DataFrame suitable for Seaborn plotting\n",
    "    median_df = (\n",
    "        pd.DataFrame({\n",
    "            feature: median_cost.index, \n",
    "            'Log Median Cost per Sqft': median_cost.values, \n",
    "            'Log Median Area': median_area.values, \n",
    "            'Log Median Price': median_price.values\n",
    "        })\n",
    "        .melt(id_vars=[feature], var_name='Metric', value_name='Log Value')\n",
    "    )\n",
    "    \n",
    "    # Create the line plot\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    ax = sns.lineplot(data=median_df, x=feature, y='Log Value', hue='Metric', marker='o')\n",
    "    \n",
    "    # Set labels and title\n",
    "    plt.xlabel(feature, fontsize=12)\n",
    "    plt.ylabel(\"Log Median Values\", fontsize=12)\n",
    "    plt.title(\"Log Median Cost per Sqft, Area, and Price by \" + feature + \" (Line Plot)\", fontsize=14)\n",
    "    plt.xticks(rotation=45)  # Rotate x-axis labels for better readability if needed\n",
    "    \n",
    "    # Move legend outside the plot area\n",
    "    plt.legend(title=\"Metric\", bbox_to_anchor=(1.05, 1), loc='upper left',fontsize=12, frameon=True)\n",
    "    \n",
    "    # Adjust layout to accommodate the legend outside the plot\n",
    "    plt.tight_layout()\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83bc4d07-2a38-4e30-8562-a358969d4628",
   "metadata": {},
   "source": [
    "plot_log_median_subplots"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "25fc79fb-e066-4ac4-bc6a-9b1620882d16",
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_log_median_subplots(df, feature):\n",
    "    fig, axes = plt.subplots(1, 4, figsize=(24, 6), sharex=True, sharey=True)\n",
    "    \n",
    "    regions = ['mumbai', 'navi mumbai', 'palghar', 'thane']\n",
    "    labels = ['Log Median costpersqft', 'Log Median area', 'Log Median price']\n",
    "    columns = ['costpersqft', 'area', 'price']\n",
    "    \n",
    "    for i, region in enumerate(regions):\n",
    "        ax = axes[i]\n",
    "        subset = df[df['addressregion'] == region]\n",
    "        \n",
    "        median_values = subset.groupby(feature)[columns].median()\n",
    "        log_median_values = np.log1p(median_values)\n",
    "        \n",
    "        for j, col in enumerate(columns):\n",
    "            sns.lineplot(\n",
    "                x=log_median_values.index,\n",
    "                y=log_median_values[col],\n",
    "                ax=ax,\n",
    "                label=f\"{labels[j]} for {region}\",\n",
    "                marker='o',\n",
    "                linewidth=2\n",
    "            )\n",
    "            \n",
    "            # Annotate each point\n",
    "            for x_val, y_val in zip(log_median_values.index, log_median_values[col]):\n",
    "                ax.text(x_val, y_val, f'{y_val:.2f}', ha='right', va='bottom', fontsize=12)\n",
    "        \n",
    "        ax.set_title(region.title(), fontsize=14, fontweight='bold')\n",
    "        ax.set_xlabel(feature, fontsize=12)\n",
    "        ax.set_ylabel(\"Log Median Values\", fontsize=12)\n",
    "        ax.grid(True, linestyle='--', alpha=0.5)\n",
    "        ax.legend(fontsize=12, frameon=True)\n",
    "\n",
    "        # Rotate x-axis labels properly\n",
    "        ax.tick_params(axis='x', rotation=45)\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2f9ee71b-0261-43c6-a5dc-ce766f13cd93",
   "metadata": {},
   "source": [
    "log median subplots for high cardinality "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "9e45eb73-5135-4765-848a-95c1073d1731",
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_log_median_subplots_high_card(df, feature):\n",
    "    fig, axes = plt.subplots(1, 4, figsize=(24, 6), sharex=True, sharey=True)\n",
    "    \n",
    "    regions = ['mumbai', 'navi mumbai', 'palghar', 'thane']\n",
    "    labels = ['Log Median costpersqft', 'Log Median area', 'Log Median price']\n",
    "    columns = ['costpersqft', 'area', 'price']\n",
    "    \n",
    "    for i, region in enumerate(regions):\n",
    "        ax = axes[i]\n",
    "        subset = df[df['addressregion'] == region]\n",
    "        \n",
    "        median_values = subset.groupby(feature)[columns].median()\n",
    "        log_median_values = np.log1p(median_values)\n",
    "        \n",
    "        for j, col in enumerate(columns):\n",
    "            sns.lineplot(\n",
    "                x=log_median_values.index,\n",
    "                y=log_median_values[col],\n",
    "                ax=ax,\n",
    "                label=f\"{labels[j]} for {region}\",\n",
    "                marker='o',\n",
    "                linewidth=2\n",
    "            )\n",
    "        \n",
    "        ax.set_title(region.title(), fontsize=14, fontweight='bold')\n",
    "        ax.set_xlabel(feature, fontsize=12)\n",
    "        ax.set_ylabel(\"Log Median Values\", fontsize=12)\n",
    "        ax.grid(True, linestyle='--', alpha=0.5)\n",
    "        ax.legend(fontsize=12, frameon=True)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf31a30f-f5a0-462b-8313-cd3c710c3fa4",
   "metadata": {},
   "source": [
    "region plot for high cardinality features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "90a1b776-d873-4aab-bc27-7c79b38384a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "def region_plots_high_card(df, feature):\n",
    "    \"\"\"\n",
    "    Plots:\n",
    "      1. Bar plot: price_category vs feature\n",
    "      2. Bar plot: feature vs addressregion\n",
    "      3. Line plot: Price vs feature (colored by addressregion)\n",
    "      4. Line plot: Area vs feature (colored by addressregion)\n",
    "      5. Line plot: Cost per Sqft vs feature (colored by addressregion)\n",
    "    \"\"\"\n",
    "    # Create a color palette based on the number of unique regions\n",
    "    region_palette = sns.color_palette(\"husl\", n_colors=df[\"addressregion\"].nunique())\n",
    "    \n",
    "    # Create a figure with a grid of 3 rows x 2 columns\n",
    "    fig = plt.figure(constrained_layout=True, figsize=(20, 20))\n",
    "    grid = gridspec.GridSpec(ncols=2, nrows=4, figure=fig)\n",
    "    \n",
    "    # 1. Bar plot: price_category vs feature at grid position (0, 0)\n",
    "    ax1 = fig.add_subplot(grid[0, 0])\n",
    "    ax1.set_title(f\"1. Barplot of '{feature}' mean and price categories\", fontsize=12)\n",
    "    sns.barplot(\n",
    "        x='price_category', y=feature, data=df, \n",
    "        estimator=np.mean, errorbar=None, ax=ax1\n",
    "    )\n",
    "    # Rotate tick labels for better readability\n",
    "    ax1.tick_params(axis='x', rotation=45, labelsize=10)\n",
    "    for label in ax1.get_xticklabels():\n",
    "        label.set_ha('right')  \n",
    "    ax1.tick_params(axis='y', labelsize=14)\n",
    "    ax1.set_xlabel('price_category', fontsize=14)\n",
    "    ax1.set_ylabel(feature, fontsize=14)\n",
    "    \n",
    "    # 2. Bar plot: feature vs addressregion at grid position (0, 1)\n",
    "    ax2 = fig.add_subplot(grid[0, 1])\n",
    "    ax2.set_title(f\"2. Bar Plot of '{feature}' mean vs 'addressregion'\", fontsize=12)\n",
    "    sns.barplot(\n",
    "        x='addressregion', y=feature, data=df,\n",
    "        estimator=np.mean, errorbar=None, ax=ax2\n",
    "    )\n",
    "    ax2.tick_params(axis='x', rotation=45, labelsize=10)\n",
    "    ax2.tick_params(axis='y', labelsize=14)\n",
    "    ax2.set_xlabel('addressregion', fontsize=14)\n",
    "    ax2.set_ylabel(feature, fontsize=14)\n",
    "    \n",
    "    # 3. Line plot: Price vs feature at grid position (1, 0)\n",
    "    ax3 = fig.add_subplot(grid[1, :])\n",
    "    ax3.set_title(f\"3. Price vs  + '{feature}'\", fontsize=12)\n",
    "    sns.lineplot(data=df, x=feature, y=\"price\", hue=\"addressregion\", ax=ax3, palette=region_palette)\n",
    "    \n",
    "    # 4. Line plot: Area vs feature at grid position (1, 1)\n",
    "    ax4 = fig.add_subplot(grid[2, :])\n",
    "    ax4.set_title(f\"4. Area vs  + '{feature}'\", fontsize=12)\n",
    "    sns.lineplot(data=df, x=feature, y=\"area\", hue=\"addressregion\", ax=ax4, palette=region_palette)\n",
    "    \n",
    "    # 5. Line plot: Cost per Sqft vs feature at grid position (2, 0)\n",
    "    ax5 = fig.add_subplot(grid[3, :])\n",
    "    ax5.set_title(f\"5. Cost per Sqft vs  + '{feature}'\", fontsize=12)\n",
    "    sns.lineplot(data=df, x=feature, y=\"costpersqft\", hue=\"addressregion\", ax=ax5, palette=region_palette)\n",
    "    \n",
    "    # If you want to hide the empty subplot at grid position (2, 1)\n",
    "    ax6 = fig.add_subplot(grid[2, 1])\n",
    "    ax6.axis('off')\n",
    "    \n",
    "    # Tight layout to ensure minimal overlapping\n",
    "    plt.tight_layout()\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "854bf7b4-dc00-4942-9cdd-8462a518d98a",
   "metadata": {},
   "source": [
    "summary table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "6aa44b77-e390-4619-9571-bdc979867cfc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def summarize_properties(df, feature):\n",
    "    \"\"\"\n",
    "    Returns a summary DataFrame containing overall metrics and region-specific counts \n",
    "    and median prices for properties, grouped by the specified feature.\n",
    "    \"\"\"\n",
    "    # Define regions of interest.\n",
    "    regions = ['mumbai', 'navi mumbai', 'thane', 'palghar']\n",
    "    \n",
    "    # Group by the feature column to compute overall metrics.\n",
    "    overall = df.groupby(feature).agg(\n",
    "        price_mean=('price', 'mean'),\n",
    "        price_median=('price', 'median'),\n",
    "        count=('price', 'count')\n",
    "    ).reset_index().rename(columns={feature: 'feature_value'})\n",
    "    \n",
    "    # Prepare lists to collect region-specific metrics for each unique feature value.\n",
    "    region_counts = {region: [] for region in regions}\n",
    "    region_median_prices = {region: [] for region in regions}\n",
    "    \n",
    "    unique_values = overall['feature_value'].unique()\n",
    "    for val in unique_values:\n",
    "        df_val = df[df[feature] == val]\n",
    "        for region in regions:\n",
    "            # Use a case-insensitive match on 'addressregion'\n",
    "            region_df = df_val[df_val['addressregion'].str.lower() == region]\n",
    "            region_counts[region].append(len(region_df))\n",
    "            median_price = region_df['price'].median() if len(region_df) > 0 else None\n",
    "            region_median_prices[region].append(median_price)\n",
    "    \n",
    "    # Add region-specific columns to the overall DataFrame.\n",
    "    for region in regions:\n",
    "        overall[region] = region_counts[region]\n",
    "        overall[f\"{region}_median_price\"] = region_median_prices[region]\n",
    "    \n",
    "    return overall"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "424a9f34-d0ad-4d45-9acc-88d90468de3c",
   "metadata": {},
   "source": [
    "region plots for categorical features "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "7f2a2c93-0e88-4da6-9761-1eb0d0833333",
   "metadata": {},
   "outputs": [],
   "source": [
    "def region_plots_for_categorical_features(df, feature):\n",
    "    \"\"\"\n",
    "    Plots various relationships between the given feature and other attributes, ensuring consistent colors for 'addressregion' and feature.\n",
    "    \"\"\"\n",
    "\n",
    "    # Define a fixed color palette for 'addressregion'\n",
    "    unique_regions = df['addressregion'].dropna().unique()\n",
    "    palette_regions = sns.color_palette(\"tab10\", len(unique_regions))\n",
    "    region_palette = dict(zip(unique_regions, palette_regions))\n",
    "\n",
    "    # Define a separate palette for the 'feature'\n",
    "    unique_feature_values = df[feature].dropna().unique()\n",
    "    palette_feature = sns.color_palette(\"tab10\", len(unique_feature_values))\n",
    "    feature_palette = dict(zip(unique_feature_values, palette_feature))\n",
    "\n",
    "    # Create a figure with a grid of 4 rows x 2 columns\n",
    "    fig = plt.figure(constrained_layout=True, figsize=(30, 30))\n",
    "    grid = gridspec.GridSpec(ncols=3, nrows=5, figure=fig)\n",
    "\n",
    "    # 7. Count plot\n",
    "    ax7 = fig.add_subplot(grid[2, 0])\n",
    "    ax7.set_title(f\"7. Count Plot of '{feature}' by 'addressregion'\")\n",
    "    sns.countplot(x=feature, hue='addressregion', data=df, ax=ax7, palette=region_palette)\n",
    "    ax7.tick_params(axis='x', rotation=45)\n",
    "\n",
    "    # 1. Bar plot: price vs feature by addressregion\n",
    "    ax1 = fig.add_subplot(grid[0, 0])\n",
    "    ax1.set_title(f\"1. Bar Plot of 'price' vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='price', hue='addressregion', data=df, ax=ax1, palette=region_palette)\n",
    "    ax1.tick_params(axis='x', rotation=45)\n",
    "\n",
    "    # 2. Bar plot: area vs feature by addressregion\n",
    "    ax2 = fig.add_subplot(grid[0, 1])\n",
    "    ax2.set_title(f\"2. Bar Plot of 'area' vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='area', hue='addressregion', data=df, ax=ax2, palette=region_palette)\n",
    "    ax2.tick_params(axis='x', rotation=45)\n",
    "\n",
    "    # 3. Bar plot: costpersqft vs feature by addressregion\n",
    "    ax3 = fig.add_subplot(grid[0, 2])\n",
    "    ax3.set_title(f\"3. Bar Plot of 'costpersqft' vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='costpersqft', hue='addressregion', data=df, ax=ax3, palette=region_palette)\n",
    "    ax3.tick_params(axis='x', rotation=45)\n",
    "\n",
    "    # 10. KDE plot: Price distribution by feature\n",
    "    ax10 = fig.add_subplot(grid[3, 0])\n",
    "    ax10.set_title(f\"10. Price Distribution by '{feature}' (KDE Plot)\")\n",
    "    sns.kdeplot(data=df, x=\"price\", hue=feature, fill=True, common_norm=False, palette=feature_palette, linewidth=1.5, ax=ax10, warn_singular=False)\n",
    "    ax10.set_xlabel(\"Price\")\n",
    "    ax10.set_ylabel(\"Density\")\n",
    "\n",
    "    # Skip plots 4, 5, and 6 if the feature is 'addressregion'\n",
    "    if feature != 'addressregion':\n",
    "        # 4. Price vs Feature (line plot)\n",
    "        ax4 = fig.add_subplot(grid[1, 0])\n",
    "        ax4.set_title(f\"4. Price vs {feature}\")\n",
    "        sns.lineplot(data=df, x=feature, y=\"price\", hue=\"addressregion\", ax=ax4, palette=region_palette)\n",
    "        ax4.tick_params(axis='x', rotation=45)\n",
    "\n",
    "        # 5. Area vs Feature (line plot)\n",
    "        ax5 = fig.add_subplot(grid[1, 1])\n",
    "        ax5.set_title(f\"5. Area vs {feature}\")\n",
    "        sns.lineplot(data=df, x=feature, y=\"area\", hue=\"addressregion\", ax=ax5, palette=region_palette)\n",
    "        ax5.tick_params(axis='x', rotation=45)\n",
    "\n",
    "        # 6. Cost per Sqft vs Feature (line plot)\n",
    "        ax6 = fig.add_subplot(grid[1, 2])\n",
    "        ax6.set_title(f\"6. Cost per Sqft vs {feature}\")\n",
    "        sns.lineplot(data=df, x=feature, y=\"costpersqft\", hue=\"addressregion\", ax=ax6, palette=region_palette)\n",
    "        ax6.tick_params(axis='x', rotation=45)\n",
    "\n",
    "    # 8. Count plot with corrected palette\n",
    "    ax8 = fig.add_subplot(grid[2, 1])\n",
    "    ax8.set_title(f\"8. Count Plot of '{feature}' by 'price_category'\")\n",
    "    sns.countplot(x='price_category', hue=feature, data=df, ax=ax8, palette=feature_palette)\n",
    "    ax8.tick_params(axis='x', rotation=90)\n",
    "\n",
    "    # 9. Median price vs feature by price_category\n",
    "    ax9 = fig.add_subplot(grid[2, 2])\n",
    "    ax9.set_title(f\"9. Median Price by '{feature}' and 'price_category'\")\n",
    "    sns.barplot(x='price_category', y='price', hue=feature, data=df, ax=ax9, estimator=np.median, errorbar=None, palette=feature_palette)\n",
    "    ax9.tick_params(axis='x', rotation=90)\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ab9fda9-7e36-4e7d-83ff-d576fa6336cc",
   "metadata": {},
   "source": [
    "plots for high cardinality categorical features "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "94bbda98-7d88-4ff0-bdf4-dec4bcefafd5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def num_charts_plot_high_card_categorical(df, feature, top_n=10):\n",
    "    \"\"\"\n",
    "    Alternative plots for a categorical feature with high cardinality,\n",
    "    displaying only the top N categories based on frequency.\n",
    "    \"\"\"\n",
    "    # Get the top N categories based on count\n",
    "    top_categories = df[feature].value_counts().nlargest(top_n).index.tolist()\n",
    "    df_filtered = df[df[feature].isin(top_categories)]\n",
    "    \n",
    "    # Sort categories based on count\n",
    "    df_filtered[feature] = pd.Categorical(df_filtered[feature], categories=top_categories, ordered=True)\n",
    "    df_filtered = df_filtered.sort_values(feature)\n",
    "    \n",
    "    # Increase figure height to accommodate plots\n",
    "    fig = plt.figure(constrained_layout=True, figsize=(20, 35))\n",
    "    grid = gridspec.GridSpec(ncols=2, nrows=16, figure=fig)\n",
    "    \n",
    "    # 1. Boxen Plot\n",
    "    ax1 = fig.add_subplot(grid[0:2, :])\n",
    "    ax1.set_title('Boxen Plot')\n",
    "    sns.boxenplot(x=df_filtered[feature], y=df_filtered['price'], ax=ax1)\n",
    "    ax1.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    # 2. Box Plot\n",
    "    ax2 = fig.add_subplot(grid[2:4, :])\n",
    "    ax2.set_title('Box Plot')\n",
    "    sns.boxplot(x=df_filtered[feature], y=df_filtered['price'], ax=ax2)\n",
    "    ax2.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    # 3. Violin Plot\n",
    "    ax3 = fig.add_subplot(grid[4:6, :])\n",
    "    ax3.set_title('Violin Plot')\n",
    "    sns.violinplot(x=df_filtered[feature], y=df_filtered['price'], data=df_filtered, ax=ax3)\n",
    "    ax3.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    # 4. Line Plot (Mean and Median)\n",
    "    ax4 = fig.add_subplot(grid[6:8, :])\n",
    "    ax4.set_title('Line Plot of Aggregated Price by ' + feature)\n",
    "    \n",
    "    # Compute aggregated values\n",
    "    agg_data = df_filtered.groupby(feature)['price'].agg(['mean', 'median']).reset_index()\n",
    "    \n",
    "    # Plot mean and median\n",
    "    ax4.plot(agg_data[feature], agg_data['mean'], marker='o', label='Mean Price', color='#1f77b4')\n",
    "    ax4.plot(agg_data[feature], agg_data['median'], marker='o', label='Median Price', color='#ff7f0e')\n",
    "    \n",
    "    ax4.legend()\n",
    "    ax4.tick_params(axis='x', rotation=90)\n",
    "    ax4.set_xlabel(feature)\n",
    "    ax4.set_ylabel('Mean and Median Price')\n",
    "    \n",
    "    # 5. Heatmap of Median Price by feature\n",
    "    ax5 = fig.add_subplot(grid[8:10, :])\n",
    "    ax5.set_title('Heatmap of Median Price by ' + feature)\n",
    "    \n",
    "    heat_data = agg_data.set_index(feature)[['median']].T\n",
    "    sns.heatmap(heat_data, annot=True, fmt=\".2f\", cmap=\"viridis\", ax=ax5, cbar=True, linewidths=0.5, linecolor='white')\n",
    "    ax5.set_xticklabels(ax5.get_xticklabels(), rotation=45, ha='right')\n",
    "    \n",
    "    # 6. Jittered Strip Plot\n",
    "    ax6 = fig.add_subplot(grid[10:12, :])\n",
    "    ax6.set_title('Jittered Strip Plot of Price by ' + feature)\n",
    "    sns.stripplot(data=df_filtered, x=feature, y='price', jitter=True, alpha=0.6, size=5, ax=ax6)\n",
    "    ax6.set_xticklabels(ax6.get_xticklabels(), rotation=90)\n",
    "    \n",
    "    # 7. Count Plot\n",
    "    ax7 = fig.add_subplot(grid[12:14, :])\n",
    "    ax7.set_title('Count Plot')\n",
    "    sns.countplot(x=df_filtered[feature], ax=ax7, order=top_categories)\n",
    "    ax7.tick_params(axis='x', rotation=90)\n",
    "    \n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "2f60eec4-5f85-4885-bba1-86c1e0af8635",
   "metadata": {},
   "outputs": [],
   "source": [
    "def region_plots_high_card_categorical(df, feature, top_n=10):\n",
    "    \"\"\"\n",
    "    Plots various relationships between the given feature and other attributes, ensuring consistent colors for 'addressregion'.\n",
    "    \"\"\"\n",
    "\n",
    "    # Get the top N categories based on count\n",
    "    top_categories = df[feature].value_counts().nlargest(top_n).index.tolist()\n",
    "    df_filtered = df[df[feature].isin(top_categories) & df['addressregion'].notna()]\n",
    "\n",
    "    # Sort categories based on count\n",
    "    df_filtered[feature] = pd.Categorical(df_filtered[feature], categories=top_categories, ordered=True)\n",
    "    df_filtered = df_filtered.sort_values(feature)\n",
    "\n",
    "    # Define a fixed color palette for 'addressregion'\n",
    "    unique_regions = df_filtered['addressregion'].unique()\n",
    "    palette = sns.color_palette(\"tab10\", len(unique_regions))  \n",
    "    region_palette = dict(zip(unique_regions, palette)) \n",
    "\n",
    "    # Create a figure with a grid\n",
    "    fig = plt.figure(constrained_layout=True, figsize=(30, 30))\n",
    "    grid = gridspec.GridSpec(ncols=3, nrows=5, figure=fig)\n",
    "\n",
    "    # 7. Count plot\n",
    "    ax7 = fig.add_subplot(grid[2, 0])\n",
    "    ax7.set_title(f\"7. Count Plot of '{feature}' by 'addressregion'\")\n",
    "    sns.countplot(x=feature, hue='addressregion', data=df_filtered, ax=ax7, palette=region_palette)\n",
    "\n",
    "    ax1 = fig.add_subplot(grid[0, 0])\n",
    "    ax1.set_title(f\"1. Price vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='price', hue='addressregion', data=df_filtered, ax=ax1, palette=region_palette)\n",
    "\n",
    "    ax2 = fig.add_subplot(grid[0, 1])\n",
    "    ax2.set_title(f\"2. Area vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='area', hue='addressregion', data=df_filtered, ax=ax2, palette=region_palette)\n",
    "\n",
    "    ax3 = fig.add_subplot(grid[0, 2])\n",
    "    ax3.set_title(f\"3. Cost per Sqft vs '{feature}' by 'addressregion'\")\n",
    "    sns.barplot(x=feature, y='costpersqft', hue='addressregion', data=df_filtered, ax=ax3, palette=region_palette)\n",
    "\n",
    "    # KDE plot\n",
    "    ax8 = fig.add_subplot(grid[2, 1])\n",
    "    ax8.set_title(f\"8. Price Distribution by '{feature}' (KDE Plot)\")\n",
    "    sns.kdeplot(data=df_filtered, x=\"price\", hue=feature, fill=True, common_norm=False, palette=\"tab10\", linewidth=1.5, ax=ax8, warn_singular=False)\n",
    "\n",
    "    # Line plots\n",
    "    ax4 = fig.add_subplot(grid[1, 0])\n",
    "    ax4.set_title(f\"4. Price vs {feature}\")\n",
    "    sns.lineplot(data=df_filtered, x=feature, y=\"price\", hue=\"addressregion\", ax=ax4, palette=region_palette)\n",
    "\n",
    "    ax5 = fig.add_subplot(grid[1, 1])\n",
    "    ax5.set_title(f\"5. Area vs {feature}\")\n",
    "    sns.lineplot(data=df_filtered, x=feature, y=\"area\", hue=\"addressregion\", ax=ax5, palette=region_palette)\n",
    "\n",
    "    ax6 = fig.add_subplot(grid[1, 2])\n",
    "    ax6.set_title(f\"6. Cost per Sqft vs {feature}\")\n",
    "    sns.lineplot(data=df_filtered, x=feature, y=\"costpersqft\", hue=\"addressregion\", ax=ax6, palette=region_palette)\n",
    "\n",
    "    # Improve readability\n",
    "    for ax in [ax1, ax2, ax3, ax4, ax5 ,ax6, ax7, ax8]:  \n",
    "        ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "b661a29a-d9c8-4b37-a215-172291f2c899",
   "metadata": {},
   "outputs": [],
   "source": [
    "def num_two_chart_plot_high_card_categorical(df, feature, top_n=10):\n",
    "    \"\"\"\n",
    "    The plots include:\n",
    "    - Distribution Plot\n",
    "    - Scatter Plot\n",
    "    \"\"\"\n",
    "    # Get the top N categories based on count\n",
    "    top_categories = df[feature].value_counts().nlargest(top_n).index.tolist()\n",
    "    df_filtered = df[df[feature].isin(top_categories) & df['addressregion'].notna()]\n",
    "\n",
    "    # Sort categories based on count\n",
    "    df_filtered[feature] = pd.Categorical(df_filtered[feature], categories=top_categories, ordered=True)\n",
    "    df_filtered = df_filtered.sort_values(feature)\n",
    "    \n",
    "    fig, axes = plt.subplots(1, 2, figsize=(12, 6))\n",
    "\n",
    "    # Distribution Plot\n",
    "    sns.histplot(df_filtered[feature], kde=True, ax=axes[0])\n",
    "    axes[0].set_title('Distribution Plot', fontsize=12)\n",
    "    axes[0].set_xlabel(feature, fontsize=12)\n",
    "    axes[0].set_ylabel('Count', fontsize=12)\n",
    "    axes[0].tick_params(axis='both', labelsize=10)\n",
    "    axes[0].tick_params(axis='x', rotation=90)  # Apply rotation to x-axis\n",
    "\n",
    "    # Scatter Plot\n",
    "    sns.scatterplot(x=df_filtered[feature], y=df_filtered['price'], ax=axes[1])\n",
    "    axes[1].set_title('Scatter Plot', fontsize=12)\n",
    "    axes[1].set_xlabel(feature, fontsize=12)\n",
    "    axes[1].set_ylabel('Price', fontsize=12)\n",
    "    axes[1].tick_params(axis='both', labelsize=10)\n",
    "    axes[1].tick_params(axis='x', rotation=90)  # Apply rotation to x-axis\n",
    "\n",
    "    # Tight layout to reduce overlapping\n",
    "    plt.tight_layout()\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "22bc19b1-0843-4348-a98e-88edd0f5843b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def summarize_properties_high_card_categorical(df, feature, top_n=10):\n",
    "    \"\"\"\n",
    "    Returns a summary DataFrame containing overall metrics and region-specific counts \n",
    "    and median prices for properties, grouped by the specified feature.\n",
    "    \"\"\"\n",
    "\n",
    "    # Get the top N categories based on count\n",
    "    top_categories = df[feature].value_counts().nlargest(top_n).index.tolist()\n",
    "    df_filtered = df[df[feature].isin(top_categories) & df['addressregion'].notna()]\n",
    "\n",
    "    # Sort categories based on count\n",
    "    df_filtered[feature] = pd.Categorical(df_filtered[feature], categories=top_categories, ordered=True)\n",
    "    df_filtered = df_filtered.sort_values(feature)\n",
    "    \n",
    "    # Define regions of interest.\n",
    "    regions = ['mumbai', 'navi mumbai', 'thane', 'palghar']\n",
    "    \n",
    "    # Group by the feature column to compute overall metrics.\n",
    "    overall = df_filtered.groupby(feature).agg(\n",
    "        price_mean=('price', 'mean'),\n",
    "        price_median=('price', 'median'),\n",
    "        count=('price', 'count')\n",
    "    ).reset_index().rename(columns={feature: 'feature_value'})\n",
    "    \n",
    "    # Prepare lists to collect region-specific metrics for each unique feature value.\n",
    "    region_counts = {region: [] for region in regions}\n",
    "    region_median_prices = {region: [] for region in regions}\n",
    "    \n",
    "    unique_values = overall['feature_value'].unique()\n",
    "    for val in unique_values:\n",
    "        df_val = df_filtered[df_filtered[feature] == val]\n",
    "        for region in regions:\n",
    "            # Use a case-insensitive match on 'addressregion'\n",
    "            region_df = df_val[df_val['addressregion'].str.lower() == region]\n",
    "            region_counts[region].append(len(region_df))\n",
    "            median_price = region_df['price'].median() if len(region_df) > 0 else None\n",
    "            region_median_prices[region].append(median_price)\n",
    "    \n",
    "    # Add region-specific columns to the overall DataFrame.\n",
    "    for region in regions:\n",
    "        overall[region] = region_counts[region]\n",
    "        overall[f\"{region}_median_price\"] = region_median_prices[region]\n",
    "    \n",
    "    return overall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "19efecda-1b5a-4135-b943-c126785d7536",
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_log_median_subplots_high_card_categorical(df, feature, top_n=10):\n",
    "    # Get the top N categories based on count\n",
    "    top_categories = df[feature].value_counts().nlargest(top_n).index.tolist()\n",
    "    df_filtered = df[df[feature].isin(top_categories) & df['addressregion'].notna()]\n",
    "\n",
    "    # Sort categories based on count\n",
    "    df_filtered[feature] = pd.Categorical(df_filtered[feature], categories=top_categories, ordered=True)\n",
    "    df_filtered = df_filtered.sort_values(feature)\n",
    "    \n",
    "    fig, axes = plt.subplots(1, 4, figsize=(24, 6), sharex=True, sharey=True)\n",
    "    \n",
    "    regions = ['mumbai', 'navi mumbai', 'palghar', 'thane']\n",
    "    labels = ['Log Median costpersqft', 'Log Median area', 'Log Median price']\n",
    "    columns = ['costpersqft', 'area', 'price']\n",
    "    \n",
    "    for i, region in enumerate(regions):\n",
    "        ax = axes[i]\n",
    "        subset = df_filtered[df_filtered['addressregion'] == region]\n",
    "        \n",
    "        # Compute median values\n",
    "        median_values = subset.groupby(feature)[columns].median()\n",
    "        \n",
    "        # Ensure all values are positive before applying log\n",
    "        median_values = median_values.replace(0, np.nan).dropna()\n",
    "        \n",
    "        log_median_values = np.log1p(median_values.dropna())\n",
    "\n",
    "        for j, col in enumerate(columns):\n",
    "            if log_median_values[col].isna().all():\n",
    "                continue  # Skip if all values are NaN\n",
    "            \n",
    "            sns.lineplot(\n",
    "                x=log_median_values.index,\n",
    "                y=log_median_values[col],\n",
    "                ax=ax,\n",
    "                label=f\"{labels[j]} for {region}\",\n",
    "                marker='o',\n",
    "                linewidth=2\n",
    "            )\n",
    "            \n",
    "            # Annotate each point\n",
    "            for x_val, y_val in zip(log_median_values.index, log_median_values[col]):\n",
    "                if np.isfinite(y_val):  # Ensure finite values before annotation\n",
    "                    ax.text(x_val, y_val, f'{y_val:.2f}', ha='right', va='bottom', fontsize=12)\n",
    "        \n",
    "        ax.set_title(region.title(), fontsize=14, fontweight='bold')\n",
    "        ax.set_xlabel(feature, fontsize=12)\n",
    "        ax.set_ylabel(\"Log Median Values\", fontsize=12)\n",
    "        ax.grid(True, linestyle='--', alpha=0.5)\n",
    "        ax.legend(fontsize=12, frameon=True)\n",
    "\n",
    "        # Rotate x-axis labels properly\n",
    "        ax.tick_params(axis='x', rotation=45)\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "c049531d-4672-463f-8534-4218b1f133a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "def median_plot_high_card_categorical(df, feature, top_n=10):\n",
    "    # Get the top N categories based on count\n",
    "    top_categories = df[feature].value_counts().nlargest(top_n).index.tolist()\n",
    "    df_filtered = df[df[feature].isin(top_categories) & df['addressregion'].notna()]\n",
    "\n",
    "    # Sort categories based on count\n",
    "    df_filtered[feature] = pd.Categorical(df_filtered[feature], categories=top_categories, ordered=True)\n",
    "    df_filtered = df_filtered.sort_values(feature)\n",
    "    \n",
    "    # Drop rows with missing values for relevant columns\n",
    "    df_filtered = df_filtered.dropna(subset=[feature, 'costpersqft', 'area', 'price'])\n",
    "    \n",
    "    # Compute median values for each category in the feature\n",
    "    median_cost = df_filtered.groupby(feature)['costpersqft'].median()\n",
    "    median_area = df_filtered.groupby(feature)['area'].median()\n",
    "    median_price = df_filtered.groupby(feature)['price'].median()\n",
    "    \n",
    "    # Apply log transformation\n",
    "    log_median_cost = np.log1p(median_cost)\n",
    "    log_median_area = np.log1p(median_area)\n",
    "    log_median_price = np.log1p(median_price)\n",
    "    \n",
    "    # Combine data for visualization\n",
    "    median_df = (\n",
    "        pd.DataFrame({\n",
    "            feature: log_median_cost.index, \n",
    "            'Log Median Cost per Sqft': log_median_cost.values, \n",
    "            'Log Median Area': log_median_area.values, \n",
    "            'Log Median Price': log_median_price.values\n",
    "        })\n",
    "        .melt(id_vars=[feature], var_name='Metric', value_name='Log Value')\n",
    "    )\n",
    "    \n",
    "    # Plot the graph\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    ax = sns.lineplot(data=median_df, x=feature, y='Log Value', hue='Metric', marker='o')\n",
    "    \n",
    "    # Annotate each point\n",
    "    for line in ax.lines:\n",
    "        for x, y in zip(line.get_xdata(), line.get_ydata()):\n",
    "            ax.text(x, y, f'{y:.2f}', ha='center', va='bottom', fontsize=9)\n",
    "    \n",
    "    # Set labels and title\n",
    "    plt.xlabel(feature, fontsize=12)\n",
    "    plt.ylabel(\"Log Median Values\", fontsize=12)\n",
    "    plt.title(\"Log Median Cost per Sqft, Area, and Price by \" + feature + \" (Line Plot)\", fontsize=14)\n",
    "    plt.xticks(rotation=45)\n",
    "    \n",
    "    # Move legend outside the plot\n",
    "    plt.legend(title=\"Metric\", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=12, frameon=True)\n",
    "    \n",
    "    # Adjust layout\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Create a sorted DataFrame (from expensive to cheapest)\n",
    "    sorted_df = pd.DataFrame({\n",
    "        feature: log_median_cost.index, \n",
    "        'log_median_costpersqft_values': log_median_cost.values  # Renamed column\n",
    "    }).sort_values(by='log_median_costpersqft_values', ascending=False)\n",
    "    \n",
    "    # Print the sorted table\n",
    "    print(sorted_df.to_string(index=False))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "208b4dd0-973f-4fab-9a9b-818293d990c8",
   "metadata": {},
   "source": [
    "`observation`  \n",
    "will do analysis of each column with price and address column also \n",
    "- Multivariate analysis on Numerical columns\n",
    "- Multivariate analysis on Categorical columns"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
